import asyncio
import platform

import logging
import typing

import socketio
from tkinter import messagebox
from _thread import start_new_thread

from aiortc import RTCPeerConnection, RTCSessionDescription
from aiortc.contrib.media import MediaPlayer

ENDPOINT_URL = 'ws://localhost:8080'

socket = socketio.AsyncClient(
    reconnection=True,
    logger=True,
)

connections: typing.Dict[str, RTCPeerConnection] = {}

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

loop = asyncio.get_event_loop()

async def accept_offer(sid: str, sdp: str, typ: str):
    pc = RTCPeerConnection()
    video_player = MediaPlayer("/dev/video0")
    pc.addTrack(video_player.video)

    @pc.on("iceconnectionstatechange")
    async def on_iceconnectionstatechange():
        print(f"ICE connection state is {pc.iceConnectionState}")

        if pc.iceConnectionState == "failed":
            await pc.close()

            if sid in connections:
                del connections[sid]

    # Do something

    description = RTCSessionDescription(sdp=sdp, type=typ)
    await pc.setRemoteDescription(description)
    answer = await pc.createAnswer()
    await pc.setLocalDescription(answer)

    connections[sid] = pc

    return {
        'sdp': pc.localDescription.sdp,
        'type': pc.localDescription.type,
    }

@socket.on(event='message', namespace='/cams')
async def handle_show_message(data: dict):
    message = data.get('message', 'Вас разбудили нахуй.')
    start_new_thread(messagebox.showinfo, ("Вам сообщение", message))


@socket.on(event='connect')
async def handle_client_connect(*_):
    logging.info("Клиент успешно подключен к сети.")

@socket.on(event='disconnect', namespace='/cams')
async def handle_disconnect(*_):
    for key, value in connections.items():
        await value.close()

    logging.info("Все RTC клиенты отключены")

@socket.on(event='accept_offer', namespace='/cams')
async def handle_create_offer(data: dict):
    frontend_sid = data.get('sid')
    sdp, type_ = data.get('sdp'), data.get('type')

    if not frontend_sid:
        return

    offer = await accept_offer(frontend_sid, sdp, type_)

    await socket.emit(
        event='stream_data',
        data={
            'sdp': offer['sdp'],
            'type': offer['type'],
            'sid': frontend_sid,
        },
        namespace='/cams'
    )

async def connect():
    await socket.connect(
        url=ENDPOINT_URL,
        transports=['websocket', 'polling'],
        wait_timeout=2,
        namespaces=[
            '/cams'
        ],
        auth={
            'computer_name': platform.node(),
        }
    )
    await socket.wait()

if __name__ == '__main__':
    loop.run_until_complete(connect())
